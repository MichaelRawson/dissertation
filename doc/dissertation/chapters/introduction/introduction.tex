\chapter{Introduction}
Lambda calculi express abstract computation, forming part of research into computability theory~\cite{lambda-computability}, programming languages~\cite{lambda-programming}, and type systems.
My dissertation describes the implementation of machine-checked proofs in the proof assistant Isabelle concerning a typed \(\lambda\)-calculus, culminating with correctness properties of the calculus.
I also produce executable Haskell code that implements a type inference algorithm for the calculus, extracting the code from the formal implementation, and supply a proof of correctness of the algorithm.

I draw on areas in theoretical Computer Science for my project: \(\lambda\)-calculi, types, formal logic, and verified reasoning.
By verifying a \emph{typed} calculus, the project required some type theory in addition to results about the \(\lambda\)-calculus, including properties such as the preservation of types under \(\beta\)-reduction.
Verification itself requires knowledge (and precise application) of formal logic, as an intuitive argument will not satisfy the checker.
Finally, the techniques used with informal proof versus verified proof must differ: while technology has improved so that an informal proof's structure remains in a verified proof, details that a human would discount as trivial are necessarily included.

\section{Project summary}
During the project, I implemented the following:
\begin{itemize}
\item
Encoding the calculus in Isabelle.
\item
\(\alpha\)-equivalence, with an unusual approach.
\item
A typing relation on the calculus.
\item
An executable type inference algorithm, shown to be correct against the typing relation.
\item
Extracted code for this inference algorithm.
\item
Safety properties of the calculus: progress, preservation, and safety.
\end{itemize}

For extension work, I implemented unit and pair terms and associated types, and showed that \(\beta\)-reduction is confluent, using a proof technique due to Tait, Martin-L\"of, and Takahashi.

\section{Previous work}
The theory behind typed \(\lambda\)-calculi is well-known: Church's \(\lambda\)-calculus has a distinguished history~\cite{lambda-history}, as do types since Russell's original \emph{theory of types}~\cite{russell}.
My work used well-established knowledge, so there was little risk of attempting a mathematically-impossible project.
Formal verification also has previous work that can be re-used: proof \emph{assistants} now include automation tools, tactics and theorem provers, and libraries of formalised mathematics: the \textsc{Mizar} system~\cite{mizar} contains a library of over 50,000 proofs.

There is also more directly-related previous work.
Several implementations of typed \(\lambda\)-calculus have been verified (see for instance the \textsc{PoplMark} challenge~\cite{poplmark}, a set of challenges designed to measure progress in mechanising programming language metatheory) using an assortment of techniques, all of which I can draw on for inspiration.

\section{Completed work}
I have met all criteria specified in the project proposal, and have added some extensions.
I define and encode in Isabelle a simply-typed calculus, and show several results about \(\alpha\)-equivalence in the calculus.
Using this encoding, I then add a typing relation, type inference and \(\beta\)-reduction to the calculus, then show the main results: progress, type-preservation, and safety.
Finishing, I show that the type inference algorithm is correct with respect to the type system, and hence also has safety properties.
