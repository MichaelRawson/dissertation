\chapter{Evaluation}
In a sense, evaluating this project sense should not be necessary: it is \emph{verified}, so the reasoning (if not the definitions) within it cannot be doubted without also doubting the soundness of Isabelle.
However, there are other metrics to the project's success other than its truth:
\begin{itemize}
\item practical examples: while the implementation is theoretically verified, practical applications may produce examples which the theory did not cover
\item performance: the algorithm as presented should perform well, at least asymptotically: it is difficult to argue this in a proof assistant, so it is easier to produce empirical data and show that (at least for a fixed input size) it behaves as expected
\item comparison to other work: the choice of representation especially is somewhat unusual, and comes with advantages and disadvantages compared to other approaches
\end{itemize}

Isabelle supports three programming languages in its code-extraction machinery: Standard ML, OCaml, Haskell, and Scala\cite{codegen-reference}.
Haskell was chosen to be the language for use evaluating the type inference algorithm: it offered better support for testing and benchmarking than Standard ML and OCaml, but remained closer to the algorithm expressed in Isabelle than Scala (which has a more complex type system).

\section{Practical Examples and Testing}
A common method of testing software is unit testing (in which code is subjected to single pass/fail test units), and random testing (in which code is tested under randomised inputs).
I used HSpec\cite{hspec}, a generic testing library for Haskell, combined with QuickCheck\cite{quickcheck}, a library for randomised testing, to test the extracted code.

I tested the following properties:
\begin{enumerate}
\item fresh variables \(x\) generated with respect to a set \(S\) have the property \(x \notin S\)
\item inferring the type of a variable in the empty context is undefined
\item inferring the type of a variable \(x\) in a context \(\Gamma\) is undefined if \(x \notin \Gamma\)
\item inferring the type of a variable \(x\) in the context \(\{x \mapsto T\}\) results in \(T\)
\item inferring the type of \(\lambda x : T.A\) is undefined when \(A\) has an undefined type
\item \(\lambda\)-terms bind their variable to the given type when it is inferred
\item \(\lambda\)-terms do not bind any other variables
\item inferring the type of applications \(f\ x\) is undefined when \(f\) is inferred as undefined
\item inferring the type of applications \(f\ x\) is undefined when \(x\) is inferred as undefined
\item inferring the type of applications is undefined when \(f\) does not have a function type
\item inferring the type of applications is also undefined when \(x\) does not match the type accepted by the input of \(f\)
\item applications have the correct type inferred when none of the above conditions hold
\end{enumerate}

These conditions were tested with the Haskell script in figure \ref{fig:hspec-tests}.
All tests pass, producing output similar to figure \ref{fig:tests-output}.
\begin{figure}
\begin{minted}[fontsize=\tiny]{Haskell}
module Main where

-- testing frameworks
import Test.Hspec
import Test.QuickCheck

-- extracted code modules
import Arith
import Fresh
import Set
import SimplyTyped
import PreSimplyTyped

-- converting integers to the natural numbers used in extracted code
int_nat :: Int -> Nat
int_nat 0 = Zero_nat
int_nat n = Suc (int_nat (n - 1))

-- generating arbitrary natural numbers is now possible
instance Arbitrary Nat where
  arbitrary = do
    n <- choose (1, 100)
    pure . int_nat $ n

main :: IO ()
main = hspec $ do
  let z = Zero_nat
  let sensible = choose (1, 100)
  let infer' c p = infer c (Abs_trm p)
  let empty = const Nothing
  let single n = if n == z then Just (TVar z) else Nothing

  describe "fresh variables" $ do
    it "fresh in a set" $ do
      property $ forAll (listOf sensible) $ \l -> let l' = map int_nat l in fresh_in (Set l') `notElem` l'
  describe "inference of variables" $ do
    it "undefined in the empty context" $ do
      property $ \n -> (infer' empty $ PVar (n :: Nat)) == Nothing

    it "undefined if fresh in a context" $ do
      let fresh_ctx n x = if n == x then Nothing else Just (TVar z) 
      property $ \n -> (infer' (fresh_ctx n) $ PVar (n :: Nat)) == Nothing

    it "defined if in a context" $ do
      let hit = Just (TVar z)
      let ctx n x = if n == x then hit else Nothing
      property $ \n -> (infer' (ctx n) $ PVar (n :: Nat)) == hit

  describe "inference of lambdas" $ do
    it "propagates type errors" $ do
      property $ \n -> (infer' empty $ PFn (n :: Nat) (TVar z) (PVar z)) == Nothing
    it "binds variables" $ do
      property $ \n -> (infer' empty $ PFn (n :: Nat) (TVar z) (PVar n)) == Just (TArr (TVar z) (TVar z))

    it "doesn't bind extraneous variables" $ do
      let ctx n x = if n == x then Just (TVar (int_nat 1)) else Nothing
      property $ \n -> (infer' (ctx n) $ PFn z (TVar z) (PVar (n :: Nat))) == Just (TArr (TVar z) (TVar (int_nat 1)))

  describe "inference of applications" $ do
    it "propagates type errors on the left" $ do
      infer' single (PApp (PVar (int_nat 1)) (PVar z)) `shouldBe` Nothing
    it "propagates type errors on the right" $ do
      infer' single (PApp (PVar z) (PVar (int_nat 1))) `shouldBe` Nothing
    it "undefined for non-function application" $ do
      infer' single (PApp (PVar z) (PVar z)) `shouldBe` Nothing
    it "undefined for type mismatch" $ do
      infer' single (PApp (PFn z (TVar (int_nat 1)) (PVar z)) (PVar z)) `shouldBe` Nothing
    it "infers correct type" $ do
      let ctx n x = if n == x then Just (TVar x) else if z == x then Just (TVar z) else Nothing
      property $ \n -> infer' (ctx n) (PApp (PFn (n :: Nat) (TVar n) (PVar z)) (PVar n)) == Just (TVar z)
\end{minted}
\caption{the HSpec tests for testing the Haskell code}
\label{fig:hspec-tests}
\end{figure}

\begin{figure}
\centering
\begin{minted}{text}
fresh variables
  fresh in a set
inference of variables
  undefined in the empty context
  undefined if fresh in a context
  defined if in a context
inference of lambdas
  propagates type errors
  binds variables
  doesn't bind extraneous variables
inference of applications
  propagates type errors on the left
  propagates type errors on the right
  undefined for non-function application
  undefined for type mismatch
  infers correct type

Finished in 0.2803 seconds
12 examples, 0 failures
\end{minted}
\caption{output from the HSpec tests}
\label{fig:tests-output}
\end{figure}

\section{Benchmarking and Performance}
Micro-benchmarking combined with Haskell code presents a number of challenges, all of which need to be overcome to make progress.

Firstly, the algorithm needs to be run on very large inputs to ensure the algorithm running time is a statistically-significant portion of the time taken.
This requires generating a large term, preferably indexed by the 

\subsection{Experimental Method}
\begin{figure}
\begin{minted}[fontsize=\tiny]{Haskell}
module Main where

-- extracted modules
import Arith
import PreSimplyTyped
import SimplyTyped

-- benchmarking framework
import Criterion.Main

-- generate a term of arbitrary size
generateTrm :: Int -> Trm Nat
generateTrm = Abs_trm . generateTrm' Zero_nat
  where
  generateTrm' vars size
    | (size == 0) = PUnit
    | (size == 1) = PVar $ case vars of
      Suc n -> n
      Zero_nat -> Zero_nat
    | (size `mod` 3 == 0) = let
      t1 = generateTrm' (Suc vars) (size `div` 2 - 1)
      t2 = generateTrm' vars (size `div` 2)
      in PApp (PFn vars (TUnit) t1) t2 
    | (size `mod` 3 == 1) = let
      t1 = generateTrm' vars (size `div` 2 -1)
      t2 = generateTrm' vars (size `div` 2)
      in PFst (PPair t1 t2)
    | (size `mod` 3 == 2) = let
      t1 = generateTrm' vars (size `div` 2 - 1)
      t2 = generateTrm' vars (size `div` 2)
      in PSnd (PPair t1 t2)

-- infer the type of a term of arbitrary size
infer' :: Int -> Maybe Type
infer' = infer ctx . generateTrm where
  ctx n = if n == Zero_nat then Just TUnit else Nothing

-- run the benchmark
main = defaultMain [
  bgroup "infer"
    [
    bench "0.1"  $ whnf infer' 100000,
    bench "0.2"  $ whnf infer' 200000,
    bench "0.3"  $ whnf infer' 300000,
    bench "0.4"  $ whnf infer' 400000,
    bench "0.5"  $ whnf infer' 500000,
    bench "0.6"  $ whnf infer' 600000,
    bench "0.7"  $ whnf infer' 700000,
    bench "0.8"  $ whnf infer' 800000,
    bench "0.9"  $ whnf infer' 900000,
    bench "1.0"  $ whnf infer' 1000000,
    bench "1.1"  $ whnf infer' 1100000,
    bench "1.2"  $ whnf infer' 1200000,
    bench "1.3"  $ whnf infer' 1300000,
    bench "1.4"  $ whnf infer' 1400000,
    bench "1.5"  $ whnf infer' 1500000,
    bench "1.6"  $ whnf infer' 1600000,
    bench "1.7"  $ whnf infer' 1700000,
    bench "1.8"  $ whnf infer' 1800000,
    bench "1.9"  $ whnf infer' 1900000,
    bench "2.0"  $ whnf infer' 20000000
    ]
  ]
\end{minted}
\caption{the Haskell code used to perform the benchmark}
\label{fig:benchmark-code}
\end{figure}

\subsection{Results}
\begin{figure}
\centering
\input{../../plots/plot}
\label{fig:asymptotic-plot}
\caption{plot showing \(O(n)\) time growth with input size}
\end{figure}

\section{Comparison to Previous Work}
\cite{head-to-head-comparison}
